
/// The code defines a struct `Board` in Rust with methods for loading board state, generating
/// move tables, playing moves, and checking for game end conditions.
/// 
/// Properties:
/// 
/// * `turn`: The `turn` property in the `Board` struct represents whose turn it is in the game. It is a
/// boolean value where `true` typically represents one player's turn and `false` represents the other
/// player's turn.
/// * `player_type`: The `player_type` property in the `Board` struct is of type `bool`. It is used to
/// indicate the type of player, where `true` might represent one player and `false` might represent the
/// other player.
/// * `my_board`: `my_board` is a field in the `Board` struct that represents the current state of the
/// player's pieces on the board. It is of type `i16` and is used to store the player's moves or
/// positions on the game board.
/// * `opp_board`: `opp_board` is a field in the `Board` struct that represents the opponent's game
/// board. It is of type `i16` which is a 16-bit signed integer in Rust. This field is used to store the
/// state of the opponent's moves in the game.
/// * `move_tables`: The `move_tables` property in the `Board` struct is a vector of `i16` values. It is
/// used to store generated moves for each game state. The `gen_move_tables` method populates this
/// vector by iterating over game states and generating moves using the `gen_move_combined`
/// * `game_states`: The `game_states` property in the `Board` struct is a vector that stores game
/// states as `i16` values. The `gen_move_tables` method populates this vector with game states
/// generated by calling the `gen_move_combined` method for each value in the range `1..511
#[derive(Clone)]
pub(crate) struct Board{
    turn: bool,
    player_type: bool,
    pub my_board: i16,
    pub opp_board: i16,
}

impl Board{
    const WIN_PATTERNS: [i16; 8]= [0b100100100, 0b10010010, 0b1001001, 0b111, 0b111000, 0b111000000, 0b100010001, 0b1010100];
    const BOARD: i16= 0b111111111;
    /// The function `load_board` in Rust updates the game board, opponent's board, turn status, and
    /// player type.
    /// 
    /// Arguments:
    /// 
    /// * `board`: The `board` parameter is of type `i16`, which typically represents a 16-bit signed
    /// integer. This parameter is used to load the current state of the game board.
    /// * `oppboard`: The `oppboard` parameter in the `load_board` function represents the opponent's
    /// game board state. It is of type `i16`, which typically indicates a 16-bit signed integer. This
    /// parameter is used to update the internal state of the game with the opponent's board
    /// configuration.
    /// * `turn`: The `turn` parameter in the `load_board` function is a boolean value that indicates
    /// whose turn it is in the game. `true` typically represents the player's turn, while `false`
    /// represents the opponent's turn.
    /// * `player_type`: The `player_type` parameter in the `load_board` function is a boolean value
    /// that indicates the type of player. It could be used to differentiate between different types of
    /// players, such as human players and AI players.
    pub fn new()->Self{
        Board { 
            turn: true, 
            player_type: true, 
            my_board: 0, 
            opp_board: 0, 
        }
    }
    pub fn change_type(&mut self) {
        self.turn= !self.turn;
        self.player_type= !self.player_type;
    }
    /// The function `gen_move` returns a 16-bit integer based on the move tables and the current board
    /// state.
    /// 
    /// Returns:
    /// 
    /// The `gen_move` function is returning an `i16` value from the `move_tables` array based on the
    /// bitwise OR operation of `my_board` and `opp_board` in the given code snippet.
    pub fn gen_move(&mut self)->i16{
        // Problem with the move tables.. Needs to be debugged thoroughly.
        //return self.move_tables[(self.my_board|self.opp_board) as usize];
        !(self.my_board|self.opp_board) & Self::BOARD
    }
    /// The function `play_move` updates the game board based on the player's move and turn.
    /// 
    /// Arguments:
    /// 
    /// * `_move`: The `_move` parameter in the `play_move` function represents the move that a player
    /// wants to make on the game board. It is of type `i16`, which is a 16-bit signed integer.
    /// * `turn`: The `turn` parameter in the `play_move` function is a boolean value that indicates
    /// whose turn it is to play the move. If `turn` is `true`, it means it's the player's turn, and the
    /// move will be applied to `self.my_board`. Otherwise, the move will be applied to `self.opp_board`.
    pub fn play_move(&mut self, _move: i16){
        if self.turn {
            self.my_board |= _move;
        } else {
            self.opp_board |= _move;
        }
        self.turn = !self.turn;
        /*
        Branchless code: Slower for reasons that my brain can't understand
        self.my_board |= _move & -(turn as i16);
        self.opp_board |= _move & -(!turn as i16);

         */
    }

    /// The `undo_move` function in Rust updates the board state by undoing a move based on the current
    /// player's turn.
    /// 
    /// Arguments:
    /// 
    /// * `_move`: The `_move` parameter in the `undo_move` function is of type `i16`, which is a 16-bit
    /// signed integer. This parameter represents the move that needs to be undone in the game logic.
    pub fn undo_move(&mut self, _move: i16){
        if self.turn {
            self.opp_board |= _move;
        } else {
            self.my_board |= _move;
        }
    }

    /// The function `has_game_ended` in Rust checks if the game has ended based on the current state of
    /// the game board.
    /// 
    /// Returns:
    /// 
    /// The function `has_game_ended` returns a boolean value indicating whether the game has ended or
    /// not. It returns `true` if either player has achieved a winning pattern on the game board or if
    /// the game board is completely filled, otherwise it returns `false`.
    pub fn has_game_ended(&mut self)-> bool{
        if self.my_board | self.opp_board >= 511 {
            return true;
        }
        for i in Self::WIN_PATTERNS {
            if i & self.my_board == i || i & self.opp_board == i {
                return true;
            }
        }
        return false;
    }

    /// The function checks if the current game state represents a win based on predefined win patterns.
    /// 
    /// Returns:
    /// 
    /// The function `is_a_win` returns a boolean value indicating whether the current game state
    /// represents a win for either the player or the opponent. If any of the win patterns in the
    /// `WIN_PATTERNS` array match either the player's board or the opponent's board, the function
    /// returns `true`, indicating a win. Otherwise, it returns `false`, indicating that there is no win
    /// yet.
    pub fn is_a_win(&self) -> bool {
        for i in Self::WIN_PATTERNS {
            if i & self.my_board == i || i & self.opp_board == i {
                return true;
            }
        }
        return false;
    }

    /// This Rust function converts a game board represented as bitboards into an array of
    /// floating-point numbers.
    /// 
    /// Returns:
    /// 
    /// A vector of type `f64` containing the board state represented as numerical values (-1.0 for
    /// opponent's pieces, 1.0 for your pieces, and 0.0 for empty spaces).
    pub fn get_board_in_array(&self) -> Vec<f64> {
        let mut board:Vec<f64>= Vec::new();
        let mut x: i16= 1;
        while x < 0b1000000000 {
            if (self.opp_board & x) !=0 {
                board.push(-1.0);
            } else if (self.my_board & x) !=0 {
                board.push(1.0);
            } else {
                board.push(0.0);
            }
            x<<= 1;
        }
        board
    }
}